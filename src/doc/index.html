<html>
  <head>
    <title>c3p0-v@c3p0.version@ - JDBC3 Connection and Statement Pooling - Documentation</title>
    <script type="text/javascript">
      function toggleDisplay( id1, id2 )
      {
        if (document.getElementById( id1 ).style.display == 'block')
        {
           document.getElementById( id1 ).style.display = 'none';
           document.getElementById( id2 ).style.display = 'block';
        }
        else
        {
           document.getElementById( id2 ).style.display = 'none';
           document.getElementById( id1 ).style.display = 'block';
        }
        return false;
      }
    </script>
    <style type="text/css">
      a.cfg_param {
         font-family: monospace;
      }
      body {
         font-family: optima, helvetica, arial, sans-serif;
      }
      dl.properties {
         padding: 0em 3em 0em 3em;
      }
      dl.properties dd {
         padding-bottom: 0.5em;
         font-size: smaller;
      }
      dl.properties dt {
         padding-top: 1em;
         border-top: 1 dashed black;
         font-family: monospace;
	 color: red;
      }
      dl.properties div.default {
         padding-top: 0.5em;
         text-decoration: underline;
         padding-bottom: 0.5em;
      }
      dl.log_properties {
         border-top: 2 solid black;
         border-left: 2 solid black;
         border-bottom: 2 solid black;
         border-right: 2 solid black;
         padding: 0.5em 0.5em 0.5em 0.5em;
         font-size: smaller;
	 background-color: #DDDDDD;
      }
      dl.log_properties dd {
         padding-top: 0.5em;
         padding-bottom: 0.5em;
         /* font-size: smaller; */
      }
      dl.log_properties dt {
         padding-top: 1em;
         font-weight: bold;
         font-family: monospace;
	 color: black;
      }
      div.boxed {
        border: 1px solid black; 
        padding: 1em; 
        font-size: smaller;
        background-color: #CCFFCC;
        margin-top: 1em;
        margin-bottom: 1em;
      }
      div.boxed h4 {
        margin-top: 0;
        padding-top: 0;
        font-weight: bold;
        text-decoration: underline;
      }
      div.deprecated {
         display: none;
         padding-top: 0;
         padding-left: 1em;
         padding-right: 1em;
         padding-bottom: 1em;
         background-color: #FFAAAA;
         border: 2px solid red;
      }
      div.deprecated h5 {
         font-weight: bold;
         color: #CC0000;
         margin-top: 0em;
         padding-top: 1em;
      }
      div.example {
         white-space: pre;
         font-family: monospace;
	 font-size: smaller;
	 background-color: #CCCCFF;
         margin: 3em 3em 3em 3em;
         padding: 1em 0em 1em 2em;
         border-top: 2 solid black;
         border-bottom: 2 solid black;
      }
      div.example_properties {
         white-space: pre;
         font-family: monospace;
	 font-size: smaller;
	 background-color: #CCCCFF;
         margin: 3em 3em 3em 3em;
         padding: 1em 0em 1em 0em;
         border-top: 2 solid black;
         border-bottom: 2 solid black;
      }
      div.example_properties strong {
         font-weight: bold;
	 color: red;
      }
      div.hibernate_props {
         text-align: center;
      }
      div.sectiontext {
         margin-left: 2em;
         margin-right: 2em;
      }
      div.subtitle {
	 font-size: 12pt;
	 background-color: #FFFFFF;
      }
      div.top_boilerplate {
         margin-left: 8em;
         margin-right: 8em;
      }

      h1 {
         text-align: center;
	 background-color: #FFCCAA;
      }
      h2 {
	 background-color: #FFFFAA;
         border-bottom: 2 solid black;
         margin-top: 2em;
      }
      h3 {
         margin-right: -2em;
      }
      ol.contents ol {
         list-style-type: lower-roman;
      }
      ol.contents ol li {
	 font-size: smaller;
      }
      ol.precedence {
        width: 75%; 
        border: 2 solid black; 
        padding-left: 3em; 
        padding-top: 1em; 
        padding-bottom: 1em; 
        padding-right: 1em; 
        text-align: left;
      }

      ol.precedence > li {
	 font-size: smaller;
         margin-top: 0.5em;
      }
      span.hibparam_comment {
         font-family: optima, helvetica, arial, sans-serif;
         font-style: italic;
         text-decoration: underline;
      }
      span.toplink {
         font-size: 12;
         font-style: plain;
         float: right;
      }

      table.hibernate_props {
         border: 2 solid black;
	 font-size: smaller;
         margin-left: auto;
         margin-right: auto;
      }
      table.hibernate_props th {
	 background-color: #FFCCAA;
      }
      table.hibernate_props td {
         font-family: monospace;
      }
      ul.pointerlist {
         list-style: square;
      }

    </style>
  </head>
  <body>
    <h1>
      <div>c3p0 - JDBC3 Connection and Statement Pooling</div>
      <div class="subtitle">version @c3p0.version@</div>
    </h1>
    <div class="top_boilerplate">
      <p>by Steve Waldman &lt;<a href="mailto:swaldman@mchange.com">swaldman@mchange.com</a>&gt;</p>
      <p>&copy; 2006 Machinery For Change, Inc.</p>
      <p><i>
	  This software is made available for use, modification, and redistribution,
	  under the terms of the <a href="../LICENSE">Lesser GNU Public License (LGPL)</a>, which you should
	  have received with this distribution.
      </i></p>
      <ul class="pointerlist"> 
	<li>API docs for c3p0 are <a href="apidocs/index.html">here</a>.</li> 
	<li>Download the latest version from <a href="http://sourceforge.net/projects/c3p0/">c3p0's site on SourceForge</a></li>
	<li>Looking for the definition of <a href="#configuration_properties">configuration properties</a>?</li>
	<li>Looking for advice in <a href="#hibernate-specific">using c3p0 with hibernate</a>?</li>
      </ul>
    </div>
    <hr/>
    <h2><a name="contents">Contents</a></h2>
    <ol class="contents">
      <li><a href="#contents">Contents</a></li>
      <li><a href="#quickstart">Quickstart</a></li>
      <li><a href="#what_is">What is c3p0?</a></li>
      <li><a href="#prerequisites">Prerequisites</a></li>
      <li><a href="#installation">Installation</a></li>
      <li>
	<a href="#using_c3p0">Using c3p0</a>
	<ol>
	  <li><a href="#using_combopooleddatasource">Using ComboPooledDataSource</a></li>
	  <li><a href="#using_datasources_factory">Using the DataSouces factory class</a></li>
	  <li><a href="#querying">Querying Pool Status</a></li>
	  <li><a href="#cleaning">Cleaning Up Pool Resources</a></li>
	  <li><a href="#build_your_own">Advanced: Building Your Own PoolBackedDataSource</a></li>
	  <li><a href="#raw_connection_ops">Advanced: Raw Connection and Statement Operations</a></li>
	</ol>
      </li>
      <li>
	<a href="#configuration">Configuration</a>
	<ol>
	  <li><a href="#configuration_introduction">Introduction</a></li>
	  <li><a href="#basic_pool_configuration">Basic Pool Configuration</a></li>
	  <li><a href="#configuring_connection_testing">Configuring Connection Testing</a></li>
	  <li><a href="#configuring_statement_pooling">Configuring Statement Pooling</a></li>
	  <li><a href="#configuring_recovery">Configuring Recovery From Database Outages</a></li>
	  <li><a href="#configuring_unresolved">Configuring Unresolved Transaction Handling</a></li>
	  <li><a href="#other_ds_configuration">Other DataSource Configuration</a></li>
	  <li><a href="#configuring_logging">Configuring Logging</a></li>
	</ol>
      </li>
      <li><a href="#known_shortcomings">Performance</a></li>
      <li><a href="#performance">Known shortcomings</a></li>
      <li><a href="#feedback_and_support">Feedback and support</a></li>
      <li><a href="#configuration_properties">Appendix A: Configuration Properties</a></li>
      <li><a href="#configuration_files">Appendix B: Configuation Files, etc.</a></li>
	<ol>
	  <li><a href="#c3p0_properties">Overriding c3p0 defaults with a c3p0.properties file</a></li>
	  <li><a href="#system_properties">Overriding c3p0 defaults with a System properties</a></li>
	  <li><a href="#c3p0-config.xml">Named and Per-User configuration: Overriding c3p0 defaults via c3p0-config.xml</a></li>
	  <li><a href="#configuration_precedence">Precedence of Configuration Settings</a></li>
	</ol>
      <li><a href="#hibernate-specific">Appendix C: Hibernate-specific notes</a></li>
      <li><a href="#tomcat-specific">Appendix D: Configuring c3p0 pooled DataSources for Apache Tomcat</a></li>
      <li><a href="#jboss-specific">Appendix E: JBoss-specific notes</a></li>
      <li><a href="#oracle-specific">Appendix F: Oracle-specific API: createTemporaryBLOB() and createTemporaryCLOB()</a></li>
    </ol>
      (See also the API Documentation <a href="apidocs/index.html">here</a>)
    <hr/>
    <h2><a name="quickstart">Quickstart</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	c3p0 was designed to be butt-simple to use. Just put
	the jar file [<tt>lib/c3p0-@c3p0.version@.jar</tt>] in your application's
	effective <tt>CLASSPATH</tt>, and make a DataSource like this:
      </p>
      <div class="example">
import com.mchange.v2.c3p0.*;
	
...
	
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass( "org.postgresql.Driver" ); //loads the jdbc driver            
cpds.setJdbcUrl( "jdbc:postgresql://localhost/testdb" );
cpds.setUser("dbuser");                                  
cpds.setPassword("dbpassword");                                  
      </div>
      <p>
	<b>[Optional]</b> If you want to turn on PreparedStatement pooling, you must also set <tt>maxStatements</tt> 
	and/or <tt>maxStatementsPerConnection</tt>(both default to 0):
      </p>
      <div class="example">
cpds.setMaxStatements( 180 );                                  
      </div>
      <p>
	Do whatever you want with your DataSource, which will be backed
	by a Connection pool set up with default parameters. You
	can bind the DataSource to a JNDI name service, or use it
	directly, as you prefer.
      </p>
      <p>
	When you are done, you can clean up the DataSource you've created
	like this:
      </p>
      <div class="example">
DataSources.destroy( cpds );
      </div>
      <p>
	That's it! The rest is detail.
      </p>
    </div>
    <h2><a name="basics">What is c3p0?</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	c3p0 is an easy-to-use library for making traditional JDBC drivers 
	"enterprise-ready" by augmenting them with functionality defined by 
	the jdbc3 spec and the optional extensions to jdbc2. In particular, 
	c3p0 provides several useful services:
      </p>
      <ul>
	<li>
	  Classes which adapt traditional DriverManager-based JDBC
	  drivers to the new <tt>javax.sql.DataSource</tt> scheme for acquiring
	  database Connections.
	</li>
	<li>
	  Transparent pooling of Connection and PreparedStatements
	  behind DataSources which can "wrap" around traditional
	  drivers or arbitrary unpooled DataSources.
	</li>
      </ul>
      <p>
	The library tries hard to get the details right:
      </p>
      <ul>
	<li>
	  c3p0 DataSources are both <tt>Referenceable</tt> and <tt>Serializable</tt>, and are thus
	  suitable for binding to a wide-variety of JNDI-based naming services.
	</li>
	<li>
	  Statement and ResultSets are carefully cleaned up when pooled
	  Connections and Statements are checked in, to prevent resource-
	  exhaustion when clients use the lazy but common resource-management
	  strategy of only cleaning up their Connections....
	</li>
	<li>
	  The library adopts the approach and uses the internal interfaces
	  defined by the JDBC 2 and 3 specification (even where these
	  conflict with the library author's preferences). DataSources
	  are written in the JavaBean style, offering all the required and
	  most of the optional properties (as well as some non-standard ones),
	  and no-arg constructors.
	</li>
      </ul>
      <p>
	c3p0 hopes to provide DataSource implementations more than suitable for 
	use by high-volume "J2EE enterprise applications". Please provide feedback, bug-fixes, etc.!
      </p>
    </div>
    <h2><a name="prerequisites">Prerequisites</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	c3p0 requires a level 1.3.x or above Java Runtime Environment, and
	the JDBC 2.x or above javax.sql libraries. c3p0 works fine under
	Java 1.4.x.
      </p>
    </div>
    <h2><a name="installation">Installation</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	Put the file <tt>lib/c3p0-@c3p0.version@.jar</tt>
	somewhere in your CLASSPATH (or any other place where your application's
	classloader will find it). That's it!
      </p>
    </div>
    <h2><a name="using_c3p0">Using c3p0</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	From a users' perspective, c3p0 simply provides standard jdbc2 DataSource
	objects. When creating these DataSources, users can control pooling-related, 
	naming-related, and other properties (See <a href="#configuration_properties">Appendix A</a>). All pooling is entirely
	transparent to users once a DataSource has been created.
      </p>
      <p>
	There are three ways of acquiring c3p0 pool-backed DataSources: 1) directly instantiate and configure a 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a> bean; 
	2) use the DataSources factory class; or 3) "build your own" pool-backed
	DataSource by directly instantiating <tt>PoolBackedDataSource</tt> and setting its <tt>ConectionPoolDataSource</tt>. Most
	users will probably find instantiating <a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>
	to be the most convenient approach. Once instantiated,
	c3p0 DataSources can be bound to nearly any JNDI-compliant name service.
      </p>
      <p>
	Regardless of how you create your DataSource, c3p0 will use defaults for any configuration parameters that
	you do not specify programmatically. c3p0 has built-in, hard-coded defaults, but you can override these by creating
	a file called <tt>c3p0.properties</tt> and storing it as a top-level resource in the same <tt>CLASSPATH</tt> / classloader
	that loads c3p0's jar file. (See <a href="#configuration">Configuration</a> below.)
      </p>
      <h3>
	<a name="using_combopooleddatasource">Instantiating and Configuring a ComboPooledDataSource</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	Perhaps the most straightforward way to create a c3p0 pooling DataSource is to instantiate an instance of 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>com.mchange.v2.c3p0.ComboPooledDataSource</tt></a>. 
	This is a JavaBean-style class with a public, no-arg constructor,
	but before you use the DataSource, you'll have to be sure to set at least the property <tt>jdbcUrl</tt>. You may also
	want to set <tt>user</tt> and <tt>password</tt>, and if you have not externally preloaded the old-style JDBC driver you'll
	use you should set the <tt>driverClass</tt>.
      </p>
<div class="example">
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass( "org.postgresql.Driver" ); //loads the jdbc driver            
cpds.setJdbcUrl( "jdbc:postgresql://localhost/testdb" );
cpds.setUser("swaldman");                                  
cpds.setPassword("test-password");                                  
	
// the settings below are optional -- c3p0 can work with defaults
cpds.setMinPoolSize(5);                                     
cpds.setAcquireIncrement(5);
cpds.setMaxPoolSize(20);
	
// The DataSource cpds is now a fully configured and usable pooled DataSource
	
...
</div>
      <p>
	The defaults of any c3p0 DataSource are determined by configuration you supply, or
	else revert to hard-coded defaults [see <a href="#configuration_properties">configuration properties</a>].
	c3p0-0.9.1 and above supports <a href="#c3p0-config.xml">multiple, named configurations</a>.
	If you wish to use a named configuration, you'd construct your 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>com.mchange.v2.c3p0.ComboPooledDataSource</tt></a>
	with the configuration name as a constructor agument:
      </p>
      <div class="example">
ComboPooledDataSource cpds = new ComboPooledDataSource("intergalactoApp");
      </div>
      <p>
	Of course, you can still override any configuration properties programmatically, as above.
      </p>
      <h3>
	<a name="using_datasources_factory">Using the DataSources factory class</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	Alternatively, you can use the static factory class 
	<a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>com.mchange.v2.c3p0.DataSources</tt></a> to build unpooled DataSources 
	from traditional JDBC drivers, and to build pooled DataSources from unpooled DataSources:
      </p>
      <div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
DataSource ds_pooled = DataSources.pooledDataSource( ds_unpooled );

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource.
// The DataSource is using a default pool configuration, and Postgres' JDBC driver
// is presumed to have already been loaded via the jdbc.drivers system property or an
// explicit call to Class.forName("org.postgresql.Driver") elsewhere.
	
...
      </div>
      <p>
	If you use the <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>
	factory class, and you want to programmatically override default configuration
	parameters, you can supply a map of override properties:
      </p>
      <div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
							      
Map overrides = new HashMap();
overrides.put("maxStatements", "200");         //Stringified property values work
overrides.put("maxPoolSize", new Integer(50)); //"boxed primitives" also work

// create the PooledDataSource using the default configuration and our overrides
ds_pooled = DataSources.pooledDataSource( ds_unpooled, overrides ); 

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource,
// with Statement caching enabled for a maximum of up to 200 statements and a maximum
// of 50 Connections.

...
      </div>
      <p>
	If you are using <a href="#c3p0-config.xml">named configurations</a>, you can specify the configuration
	that defines the default configuration for your DataSource:
      </p>
      <div class="example">
// create the PooledDataSource using the a named configuration and specified overrides
ds_pooled = DataSources.pooledDataSource( ds_unpooled, "intergalactoAppConfig", overrides ); 
      </div>

      <p><a id="showDataSourcesWithPoolConfig" 
	    style="display: block"
	    href="#" 
	    onClick="return toggleDisplay('showDataSourcesWithPoolConfig', 'DataSourcesWithPoolConfig');"
	    >Show deprecated PoolConfig approach...</a></p>
      <div class="deprecated" style="display: none" id="DataSourcesWithPoolConfig">
	<h5>Deprecated! Programmatic configuration via PoolConfig</h5>
	<p>
	  If you use the <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>
	  factory class, and you want to programmatically override default configuration
	  parameters, make use of the <a href="apidocs/com/mchange/v2/c3p0/PoolConfig.html"><tt>PoolConfig</tt></a> class:
	</p>
	<div class="example">
DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                        "swaldman", 
                                                        "test-password");
							      
PoolConfig pc = new PoolConfig();
pc.setMaxStatements(200);  //turn on Statement pooling

// pass our overriding PoolConfig to the DataSources.pooledDataSource() factory method.

ds_pooled = DataSources.pooledDataSource( ds_unpooled, pc ); 

// The DataSource ds_pooled is now a fully configured and usable pooled DataSource,
// with Statement caching enabled for a maximum of up to 200 statements.

...
	</div>
	<a id="hideDataSourcesWithPoolConfig" 
	   href="#" 
	   onClick="return toggleDisplay('showDataSourcesWithPoolConfig', 'DataSourcesWithPoolConfig');"
	   >Hide deprecated PoolConfig approach</a>
      </div>
  
      <div class="boxed">
	<h4>RARE: Forcing authentication information, regardless of (mis)configuration of the underlying (unpooled) DataSource</h4>
	<p>
	  You can wrap any DataSouce using <tt>DataSource.pooledDataSource( ... )</tt>, usually with no
	  problem whatsoever. DataSources are supposed to indicate the username and password associated
	  by default with Connections via standard properties <tt>user</tt> and <tt>password</tt>. 
	  Some DataSource implementations do not offer these properties. Usually this is not at all
	  a problem. <tt>c3p0</tt> works around this
	  by acquiring "default" Connections from the DataSource if it can't find default authentication
	  information, and a client has not specified the authentification information via 
	  <tt>getConnection( user, password )</tt>.
	</p>
	<p>
	  However, in rare circumstances, non-c3p0 unpooled DataSources provide a <tt>user</tt> property, 
	  but not a password property, or you have access to a DataSource that you wish to wrap behind a pool,
	  but you wish to override its build-in authentification defaults without actually modifying the <tt>user</tt>
	  or <tt>password</tt> properties.
	</p>
	<p>
	  <tt>c3p0</tt> provides configuation properties <tt>overrideDefaultUser</tt> and <tt>overrideDefaultPassword</tt>.
	  If you set these properties, programmatically as above, or via any of c3p0's <a href="#configuration">configuration mechanisms</a>,
	  <tt>c3p0</tt> PooledDataSources will ignore the user and password property associated with the underlying DataSource,
	  and use the specified overrides instead.
	</p>
      </div>
      <h3>
	<a name="querying">Querying a PooledDataSource's current status</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	c3p0 DataSources backed by a pool, which include implementations of 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a> and
	the objects returned by <tt><a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.pooledDataSource( ... )</tt>, 
	all implement the interface
	<a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>com.mchange.v2.c3p0.PooledDataSource</tt></a>, 
	which makes available a number of methods for querying the status of
	DataSource Connection pools. Below is sample code that queries a DataSource for its 
	status:
      </p>
      <div class="example">
// fetch a JNDI-bound DataSource
InitialContext ictx = new InitialContext();
DataSource ds = (DataSource) ictx.lookup( "java:comp/env/jdbc/myDataSource" );

// make sure it's a c3p0 PooledDataSource
if ( ds instanceof PooledDataSource)
{
  PooledDataSource pds = (PooledDataSource) ds;
  System.err.println("num_connections: "      + pds.getNumConnectionsDefaultUser());
  System.err.println("num_busy_connections: " + pds.getNumBusyConnectionsDefaultUser());
  System.err.println("num_idle_connections: " + pds.getNumIdleConnectionsDefaultUser());
  System.err.println();
}
else
  System.err.println("Not a c3p0 PooledDataSource!");
      </div>
      <p>
	The status querying methods all come in three overloaded forms, such as:
      </p>
      <ul>
	<li><tt>public int getNumConnectionsDefaultUser()</tt></li>
	<li><tt>public int getNumConnections(String username, String password)</tt></li>
	<li><tt>public int getNumConnectionsAllUsers()</tt></li>
      </ul>
      <p>
	c3p0 maintains separate pools for Connections with distinct
	authentications. The various methods let you query the status of pools individually,
	or aggregate statistics for all authentifications for which your DataSource is maintaining
	pools. <i>Note that pool configuration parmeters such as <tt>maxPoolSize</tt> are enforced
	  on a per-authentification basis!</i> For example, if you have set <tt>maxPoolSize</tt> to
	20, and if the DataSource is managing connections under two username-password pairs [the
	default, and one other pair established via a call to <tt>getConnection(user, password)</tt>, 
	you should expect to see as many as 40 Connections from <tt>getNumConnectionsAllUsers()</tt>. 
      </p>
      <p>
	<i>
	  Most applications only acquire default-authenticated Connections from DataSources, and
	  can typically just use the <tt>getXXXDefaultUser()</tt> to gather Connection statistics.
	</i>
      </p>
      <div class="boxed">
	<h4>Using C3P0Registry to get a reference to a DataSource</h4>
	<p>
	  If it's inconvenient or impossible to get a reference to your DataSource via JNDI or some other means,
	  you can find all live c3p0 DataSources using the
	  <a href="apidocs/com/mchange/v2/c3p0/C3P0Registry.html"><tt>C3P0Registry</tt></a> class, which includes
	  three static methods to help you out:
	</p>
	<ul>
	  <li><tt>public static Set getPooledDataSources()</tt></li>
	  <li><tt>public static Set pooledDataSourcesByName( String dataSourceName )</tt></li>
	  <li><tt>public static <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html">PooledDataSource</a>  
              pooledDataSourcesByName( String dataSourceName )</tt></li>
	</ul>
	<p>
	  The first method will hand you the Set of all live c3p0 
	  <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html">PooledDataSources</a>. If you are sure
	  your application only makes one <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html">PooledDataSources</a>,
	  or you can distinguish between the DataSources by their configuration properties (inspected via "getters"), the 
	  first method may be sufficient. Because this will not always be the case, c3p0 
	  <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html">PooledDataSources</a> have a special property called
	  <tt>dataSourceName</tt>. You can set the <tt>dataSourceName</tt> property directly when you construct your 
	  DataSource, or dataSourceName can be set like any other property in a named or the default config. 
	  Otherwise, <tt>dataSourceName</tt> will default to either 1) the name of your DataSource's configuration, if
	  you constructed it with a <a href="#c3p0-config.xml">named configuration</a>; or 2) a unique (but unpredicatble)
	  name if you are using the default configuration.
	</p>
	<p>
	  There is no guarantee that a <tt>dataSourceName</tt> will be unique. For example, if two c3p0 DataSources share
	  the same named configuation, and you have not set the <tt>dataSourceName</tt> programmatically, the two
	  data sources will share the name of the configuration. To get all of the DataSources with a particular
	  <tt>dataSourceName</tt>, use <tt>pooledDataSourcesByName( ... )</tt>. If you've ensured that your DataSource's
	  name is unique (as you will generally want to do, if you intend to use 
	  <a href="apidocs/com/mchange/v2/c3p0/C3P0Registry.html"><tt>C3P0Registry</tt></a> to find your DataSources),
	  you can use the convenience method <tt>pooledDataSourceByName( ... )</tt>, which will return your DataSource
	  directly, or <tt>null</tt> if no DataSource with that name is available. If you use <tt>pooledDataSourceByName( ... )</tt>
	  and more than one DataSource shares the name supplied, which one it will return is undefined.
	</p>
      </div>
      <h3>
	<a name="cleaning">Cleaning up after c3p0 PooledDataSources</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	The easy way to clean up after c3p0-created DataSources is to use the static destroy method
	defined by the class <a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>. Only 
	<a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>s 
	need to be cleaned up, but 
	<a href="apidocs/com/mchange/v2/c3p0/DataSources.html">DataSources</a>.destroy( ... ) does no harm if it is called on an unpooled or non-c3p0
	DataSource.
      </p>
      <div class="example">
DataSource ds_pooled   = null;
	
try
{
  DataSource ds_unpooled = DataSources.unpooledDataSource("jdbc:postgresql://localhost/testdb", 
                                                          "swaldman", 
                                                          "test-password");
  ds_pooled = DataSources.pooledDataSource( ds_unpooled );

  // do all kinds of stuff with that sweet pooled DataSource...
}
finally
{
  DataSources.destroy( ds_pooled );
}
      </div>
      <p>
	Alternatively, c3p0's <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	interface contains a <tt>close()</tt> method
	that you can call when you know you are finished with a DataSource. So, you can cast a c3p0
	derived DataSource to a <tt>PooledDataSource</tt> and close it:
      </p>
  <div class="example">
static void cleanup(DataSource ds) throws SQLException
{
  // make sure it's a c3p0 PooledDataSource
  if ( ds instanceof PooledDataSource)
  {
    PooledDataSource pds = (PooledDataSource) ds;
    pds.close();
  }     
  else
    System.err.println("Not a c3p0 PooledDataSource!");
}
  </div>
      <p>
	Unreferenced instances of <a href="apidocs/com/mchange/v2/c3p0/PooledDataSource.html"><tt>PooledDataSource</tt></a>
	that are not <tt>close()</tt>ed by clients
	<tt>close()</tt> themselves prior to garbage collection in their <tt>finalize()</tt> methods. 
	As always, finalization should be considered
	a backstop and not a prompt or sure approach to resource cleanup.
      </p>
      <h3>
	<a name="build_your_own">Advanced: Building your own PoolBackedDataSource</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	There is little reason for most programmers to do this, but you can build a pooling DataSource in a
	step-by-step way by instantiating and configuring an unpooled <tt>DriverManagerDataSource</tt>, instantiating a
	<tt>WrapperConnectionPoolDataSource</tt> and setting the unpooled DataSource as its <tt>nestedDataSource</tt> property,
	and then using that to set the <tt>connectionPoolDataSource</tt> property of a new <tt>PoolBackedDataSource</tt>.
      </p>
      <p>
	This sequence of events is primarily interesting if your driver offers an implementation of ConnectionPoolDataSource, and you'd
	like c3p0 to use that. Rather than using c3p0's <tt>WrapperConnectionPoolDataSource</tt>, you can create a <tt>PoolBackedDataSource</tt>
	and set its <tt>connectionPoolDataSource</tt> property. 
      </p>
      <h3>
	<a name="raw_connection_ops">Advanced: Raw Connection and Statement Operations</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	JDBC drivers sometimes define vendor-specific, non-standard API on Connection and Statement implementations. C3P0 wraps
	these Objects behind a proxies, so you cannot cast C3P0-returned Connections or Statements to the vendor-specific implementation
	classes. C3P0 does not provide any means of accessing the raw Connections and Statements directly, because C3P0 needs to keep
	track of Statements and ResultSets created in order to prevent resource leaks and pool
	corruption.
      </p>
      <p>
	C3P0 does provide an API that allows you to invoke non-standard methods reflectively on an underlying
	Connection. To use it, first cast the returned Connection to a 
	<a href="apidocs/com/mchange/v2/c3p0/C3P0ProxyConnection.html"><tt>C3P0ProxyConnection</tt></a>. Then call
	the method <tt>rawConnectionOperation</tt>, supplying the <tt>java.lang.reflect.Method</tt> object for
	the non-standard method you wish to call as an argument. The <tt>Method</tt> you supply will be invoked
	on the target you provide on the second argument (null for static methods), and using the arguments you
	supply in the third argument to that function. For the target, and for any of the method arguments, you
	can supply the special token <tt>C3P0ProxyConnection.RAW_CONNECTION</tt>, which will be replaced with
	the underlying vendor-specific Connection object before the <tt>Method</tt> is invoked.
      </p>
      <p>
	<a href="apidocs/com/mchange/v2/c3p0/C3P0ProxyStatement.html"><tt>C3P0ProxyStatement</tt></a> offers
	an exactly analogous API.
      </p>
      <p>
	Any Statements (including Prepared and CallableStatements) and ResultSets returned by raw operations
	will be c3p0-managed, and will be properly cleaned-up on <tt>close()</tt> of the parent proxy Connection.
	Users must take care to clean up any non-standard resources returned by a vendor-specific method.
      </p>
      <p>
	Here's an example of using Oracle-specific API to call a static method on a raw Connection:
      </p>
      <div class="example">
C3P0ProxyConnection castCon = (C3P0ProxyConnection) c3p0DataSource.getConnection();
Method m = CLOB.class.getMethod("createTemporary", new Class[]{Connection.class, boolean.class, int.class});
Object[] args = new Object[] {C3P0ProxyConnection.RAW_CONNECTION, Boolean.valueOf( true ), new Integer( 10 )};
CLOB oracleCLOB = (CLOB) castCon.rawConnectionOperation(m, null, args);			
      </div>
      <p>
	<i>Note: C3P0 now includes special support for some Oracle-specific methods. 
	  See <a href="#oracle-specific">Appendix F</a>.
	</i>
      </p>
      <h2><a name="configuration">Configuration</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
      <h3>
	<a name="programmatic_configuration"></a><a name="configuration_introduction">Introduction</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	While c3p0 does not <i>require</i> very much configuration, it is very tweakable. All the interesting
	knobs and dials are represented as JavaBean properties. Following JavaBean conventions, we note that
	if an Object has a property of type <tt>T</tt> called <tt>foo</tt>, it will have methods that look
	like...
	<blockquote><tt>
	    public T getFoo();<br/>
	    public void setFoo(T foo);
	</tt></blockquote>
	...or both, depending upon whether the property is read-only, write-only, or read-writable.
      </p>
      <p>
	There are two ways to modify c3p0 properties: 
	You can directly alter the property values associated with a particular DataSource in your code, 
	or you can configure c3p0 externally, 
	via a <a href="#c3p0_properties">simple Java properties file</a>,
	via an <a href="#c3p0-config.xml">XML configuration file</a>, or  
	via <a href="#system_properties">System properties</a>.
      </p>
      <p>
	DataSources are usually configured before they are used, either
	during or immediately following their construction. c3p0 does
	support property modifications midstream, however.
      </p>
      <p>
	If you obtain a DataSource by instantiating a 
	<a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>, 
	configure it by simply calling appropriate setter methods offered by that class
	before attempting a call to <tt>getConnection()</tt>. See the example above.
      </p>
      <p>
	If you obtain a DataSource by using factory methods of
	the utility class <a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>com.mchange.v2.c3p0.DataSources</tt></a>,
	and wish to use a non-default configuration, you can supply a Map of property names (beginning with lower-case letters)
	to property values (either as Strings or "boxed" Java primitives like Integer or Boolean).
      </p>
      <p>
	All tweakable properties are documented for reference
	in <a href="#configuration_properties">Appendix A</a>. The most basic and important c3p0 configuration
	topics are discussed below.
      </p>
      <h3>
	<a name="basic_pool_configuration">Basic Pool Configuration</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	c3p0 Connection pools are very easy to configure via the following basic parameters:
      </p>
      <ul>
	<li><a class="cfg_param" href="#acquireIncrement">acquireIncrement</a></li>
	<li><a class="cfg_param" href="#initialPoolSize">initialPoolSize</a></li>
	<li><a class="cfg_param" href="#maxPoolSize">maxPoolSize</a></li>
	<li><a class="cfg_param" href="#maxIdleTime">maxIdleTime</a></li>
	<li><a class="cfg_param" href="#minPoolSize">minPoolSize</a></li>
      </ul>
      <p>
	<tt>initialPoolSize</tt>, <tt>minPoolSize</tt>, <tt>maxPoolSize</tt>
	define the number of Connections that will be pooled. Please ensure that
	<tt>minPoolSize &lt;= maxPoolSize</tt>. Unreasonable values of <tt>initialPoolSize</tt> will
	be ignored, and <tt>minPoolSize</tt> will be used instead.
      </p>
      <p>
	Within the range between <tt>minPoolSize</tt> and <tt>maxPoolSize</tt>, the number of Connections in
	a pool varies according to usage patterns. The number of Connections increases whenever a Connection
	is requested by a user, no Connections are available, and the pool has not yet reached <tt>maxPoolSize</tt>
	in the number of Connections managed. Since Connection acquisition is very slow, it is almost always useful to
	increase the number of Connections eagerly, in batches, rather than forcing each client to wait for a new
	Connection to provoke a single acquisition when the load is increasing. <tt>acquireIncrement</tt> determines
	how many Connections a c3p0 pool will attempt to acquire when the pool has run out of Connections. (Regardless
	of <tt>acquireIncrement</tt>, the pool will never allow <tt>maxPoolSize</tt> to be exceeded.)
      </p>
      <p>
	The number of Connections in a pool decreases whenever a pool tests a Connection and finds it to be broken (see
	<a href="#configuring_connection_testing">Configuring Connection Testing</a> below, or when a Connection is expired
	by the pool after sitting idle for a period of time. By default, pools will never expire idle Connections. If you wish
	idle Connections to be expired over time, set <tt>maxIdleTime</tt>.
      </p>
      <h3>
	<a name="configuring_connection_testing">Configuring Connection Testing</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	c3p0 can be configured to test the Connections that it pools in a variety of ways, to
	minimize the likelihood that your application will see a broken or "stale" Connection.
	Pooled Connections can go bad for a variety of reasons -- some JDBC drivers intentionally
	"time-out" long-lasting database Connections; back-end databases or networks sometimes go down 
	"stranding" pooled Connections; and Connections can simply become corrupted over time and use due
	to resource leaks, driver bugs, or other causes.
      </p>
      <p>
	c3p0 provides users a great deal of flexibility in testing Connections, via the following
	configuration parameters:
      </p>
      <ul>
	<li><a class="cfg_param" href="#automaticTestTable">automaticTestTable</a></li>
	<li><a class="cfg_param" href="#connectionTesterClassName">connectionTesterClassName</a></li>
	<li><a class="cfg_param" href="#idleConnectionTestPeriod">idleConnectionTestPeriod</a></li>
	<li><a class="cfg_param" href="#preferredTestQuery">preferredTestQuery</a></li>
	<li><a class="cfg_param" href="#testConnectionOnCheckin">testConnectionOnCheckin</a></li>
	<li><a class="cfg_param" href="#testConnectionOnCheckout">testConnectionOnCheckout</a></li>
      </ul>
      <p>
	<tt>idleConnectionTestPeriod</tt>, <tt>testConnectionOnCheckout</tt>, and
	<tt>testConnectionOnCheckin</tt> control <i>when</i> Connections will be tested.
	<tt>automaticTestTable</tt>, <tt>connectionTesterClassName</tt>, and <tt>preferredTestQuery</tt> control <i>how</i>.
      </p>
      <p>
	When configuring
	Connection testing, first try to minimize the cost of each test. By default, Connections are tested
	by calling the <tt>getTables()</tt> method on a Connection's associated <tt>DatabaseMetaData</tt>
	object. This has the advantage of working with any database, and is independent of database schema. However, empirically
	a <tt>DatabaseMetaData.getTables()</tt> call is often much slower than a simple database query.
      </p>
      <p>
	The most convenient way to speed up Connection testing is to define the parameter <tt>automaticTestTable</tt>. Using the name
	you provide, c3p0 will create an empty table, and make a simple query against it to test the database. Alternatively, if your 
	database schema
	is fixed prior to your application's use of the database, you can simply define a test query with the <tt>preferredTestQuery</tt>
	parameter. Be careful, however. Setting <tt>preferredTestQuery</tt> will lead to errors as Connection tests fail
	if the query target table does not exist in your database table <i>prior to initialization of your DataSource</i>. (Advanced
	users may define any kind of Connection testing they wish, by implementing the interface 
	<a href="apidocs/com/mchange/v2/c3p0/ConnectionTester.html">ConnectionTester</a> or 
	<a href="apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html">QueryConnectionTester</a>, and supplying the
	fully qualified name of the class as <tt>connectionTesterClassName</tt>.)
      </p>
      <p>
	The most reliable time to test Connections is on check-out. But this is also the most costly choice
	from a performance perspective. Most applications should work quite reliably using a combination of 
	<tt>idleConnectionTestPeriod</tt> and <tt>testConnectionsOnCheckIn</tt>. Both the idle test and the check-in 
	test are performed asynchronously, which leads to better performance, both perceived and actual.
      </p>
      <p>
	Note that for many applications, high performance is more important than the risk of an occasional database exception.
	In its default configuration, c3p0 does no Connection testing at all. Setting a fairly long 
	<tt>idleConnectionTestPeriod</tt>, and not testing on checkout and check-in at all is an excellent, high-performance
	approach.
      </p>
      <h3>
	<a name="configuring_statement_pooling">Configuring Statement Pooling</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	c3p0 implements transparent PreparedStatement pooling as defined by the JDBC spec. Under some circumstances,
	statement pooling can dramatically improve application performance. Under other circumstances, the overhead of
	statement pooling can slightly harm
	performance. Whether and how much statement pooling will help depends on how much 
	parsing, planning, and optimizing of queries your databases does when the statements are prepared. 
	Databases (and JDBC drivers) vary widely
	in this respect. It's a good idea to benchmark your application with and without statement pooling to 
	see if and how much it helps.
      </p>
      <p>
	You configure statement pooling in c3p0 via the following
	configuration parameters:
      </p>
      <ul>
	<li><a class="cfg_param" href="#maxStatements">maxStatements</a></li>
	<li><a class="cfg_param" href="#maxStatementsPerConnection">maxStatementsPerConnection</a></li>
      </ul>
      <p>
	<tt>maxStatements</tt> is JDBC's standard parameter for controlling statement pooling. <tt>maxStatements</tt> defines the
	total number <tt>PreparedStatements</tt> a DataSource will cache. The pool will destroy the least-recently-used PreparedStatement
	when it hits this limit. This sounds simple, but it's actually a strange approach, because
	cached statements conceptually belong to individual Connections; they are not global resources. To figure out a size
	for <tt>maxStatements</tt> that does not "churn" cached statements, you need to consider the number of <i>frequently used</i> 
	PreparedStatements in your application,	and multiply that by the number of Connections you expect in the pool (<tt>maxPoolSize</tt>
	in a busy application).
      </p>
      <p>
	<tt>maxStatementsPerConnection</tt> is a non-standard configuration parameter that makes a bit more
	sense conceptually. It defines how many statements each pooled Connection is allowed to own.
	You can set this to a bit more than the number of <tt>PreparedStatements</tt> your application <i>frequently</i>
	uses, to avoid churning.
      </p>
      <p>
	If either of these parameters are greater than zero, statement pooling will be enabled. If both
	parameters are greater than zero, both limits will be enforced. If only one is greater than zero, statement pooling
	will be enabled, but only one limit will be enforced.
      </p>
      <h3>
	<a name="configuring_recovery">Configuring Recovery From Database Outages</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	c3p0 DataSources are designed (and configured by default) to recover from temporary database outages, such as
	those which occur during a database restart or brief loss of network connectivity.
	You can affect how c3p0 handles errors in acquiring Connections via the following
	configurable properties:
      </p>
      <ul>
	<li><a class="cfg_param" href="#acquireRetryAttempts">acquireRetryAttempts</a></li>
	<li><a class="cfg_param" href="#acquireRetryDelay">acquireRetryDelay</a></li>
	<li><a class="cfg_param" href="#breakAfterAcquireFailure">breakAfterAcquireFailure</a></li>
      </ul>
      <p>
	When a c3p0 DataSource attempts and fails to acquire a Connection, it will retry up
	to <tt>acquireRetryAttempts</tt> times, with a delay of <tt>acquireRetryDelay</tt>
	between each attempt. If all attempts fail, any clients waiting for Connections from
	the DataSource will see an Exception, indicating that a Connection could not be acquired.
	Note that clients do not see any Exception until a full round of attempts fail, which
	may be some time after the initial Connection attempt. If <tt>acquireRetryAttempts</tt> 
	is set to 0, c3p0 will attempt to acquire new Connections indefinitely, and calls to
	<tt>getConnection()</tt> may block indefinitely waiting for a successful acquisition.
      </p>
      <p>
	Once a full round of acquisition attempts fails, there are two possible policies. By
	default, the c3p0 DataSource will remain active, and will try again to acquire Connections
	in response to future requests for Connections. If you set <tt>breakAfterAcquireFailure</tt>
	to <tt>true</tt>, the DataSource will consider itself broken after a failed round of
	Connection attempts, and future client requests will fail immediately.
      </p>
      <p>
	Note that if a database restart occurs, a pool may contain previously acquired but now
	stale Connections. By default, these stale Connections will only be detected and
	purged lazily, when an application attempts to use them, and sees an Exception. If you
	wish to avoid application Exceptions, you must adopt a connection testing strategy that
	is likely to detect stale Connections prior to their delivery to clients. (See 
	"<a href="#configuring_connection_testing">Configuring Connection Testing</a>".) Even
	with active Connection testing (<tt>testConnectionsOnCheckout</tt> set to <tt>true</tt>, or
	<tt>testConnectionsOnCheckin</tt> and a short <tt>idleConnectionTestPeriod</tt>), your
	application may see occasional Exceptions on database restart, for example if the restart 
	occurs after a Connection to the database has already been checked out.
      </p>
      <h3>
	<a name="configuring_unresolved">Configuring Unresolved Transaction Handling</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	Connections checked into a pool cannot have any unresolved transactional work associated with them.
	If users have set <tt>autoCommit</tt> to <tt>false</tt> on a Connection, and c3p0 cannot guarantee
	that there is no pending transactional work, c3p0 must either <tt>rollback()</tt> or <tt>commit()</tt>
	on check-in (when a user calls <tt>close()</tt>). The JDBC spec is (unforgivably) silent on the question
	of whether unresolved work should be committed or rolled back on Connection close. By default, c3p0
	rolls back unresolved transactional work when a user calls <tt>close()</tt>.
      </p>
      <p>
	You can adjust this behavior via the following configuration properties:
      </p>
      <ul>
	<li><a class="cfg_param" href="#autoCommitOnClose">autoCommitOnClose</a></li>
	<li><a class="cfg_param" href="#forceIgnoreUnresolvedTransactions">forceIgnoreUnresolvedTransactions</a></li>
      </ul>
      <p>
	If you wish c3p0 to allow unresolved transactional work to commit on checkin, set <tt>autoCommitOnClose</tt>
	to true. If you wish c3p0 to leave transaction management to you, and neither commit nor rollback (nor modify
	the state of Connection <tt>autoCommit</tt>), you may set <tt>forceIgnoreUnresolvedTransactions</tt> to true. Setting
	<tt>forceIgnoreUnresolvedTransactions</tt> is strongly discouraged, because if clients are not careful to
	commit or rollback themselves prior to close(), or do not set Connection <tt>autoCommit</tt> consistently, bizarre
	unreproduceable behavior and database lockups can occur.
      </p>
      <h3>
	<a name="other_ds_configuration">Other DataSource Configuration</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	See <a href="#configuration_properties">Appendix A</a> for information about the following configuration properties:
      </p>
      <ul>
	<li><a class="cfg_param" href="#checkoutTimeout">checkoutTimeout</a></li>
	<li><a class="cfg_param" href="#factoryClassLocation">factoryClassLocation</a></li>
	<li><a class="cfg_param" href="#numHelperThreads">numHelperThreads</a></li>
	<li><a class="cfg_param" href="#usesTraditionalReflectiveProxies">usesTraditionalReflectiveProxies</a></li>
      </ul>
      <h3>
	<a name="configuring_logging">Configuring Logging</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h3>
      <p>
	c3p0 uses a custom logging library similar to jakarta commons-logging. Log messages can be directed to
	the popular log4j logging library, to the standard logging facility introduced with jdk1.4, or to
	<tt>System.err</tt>. Nearly all configuration should be done at the level of your preferred logging
	library. There are a very few configuration options specific to c3p0's logging, and usually the defaults
	will be fine. Logging-related parameters
	may be placed in your <tt>c3p0.properties</tt> file, in a file called <tt>mchange-log.properties</tt> at
	the top-level of your classpath, or they may be defined as System properties. See the 
	<a href="#log_properties_box">box</a> below.
      </p>
      <p>
	c3p0's logging behavior is affected by certain build-time options. If build-option <tt>c3p0.debug</tt> is set
	to <tt>false</tt>, all messages at a logging level below INFO will be suppressed. Build-option <tt>c3p0.trace</tt> controls how fine-grained c3p0's below
	INFO level reporting will be. For the moment, distributed
	c3p0 binaries are compiled with <tt>debug</tt> set to <tt>true</tt> and <tt>trace</tt> set to its maximum level of <tt>10</tt>.
	But binaries may eventually be
	distributed with <tt>debug</tt> set to <tt>false</tt>. (For the moment, the performance impact of the logging level-checks seems
	very small, and it's most flexible to compile in all the messages, and let your logging library control which are emitted.) When
	c3p0 starts up, it emits the build-time values of debug and trace, along with the version and build time.
      </p>
      <dl class="log_properties">
	<a name="log_properties_box" />
	<dt><a name="com.mchange.v2.log.MLog" />com.mchange.v2.log.MLog</dt>
	<dd>
	  <div class="propdesc">
	    Determines which library c3p0 will output log messages to. By default, if log4j is available,
	    it will use that library, otherwise if jdk1.4 logging apis are available it will use those,
	    and if neither are available, it will use a simple fallback that logs to <tt>System.err</tt>.
	    If you want to directly control which library is used, you may set this property to one of:
	    <ul>
	      <li><tt>com.mchange.v2.log.log4j.Log4jMLog</tt></li>
	      <li><tt>com.mchange.v2.log.jdk14logging.Jdk14MLog</tt></li>
	      <li><tt>com.mchange.v2.log.FallbackMLog</tt></li>
	    </ul>
	    You may also set this property to a comma separated list of the above alternatives, to
	    define an order of preference among logging libraries.
	  </div>
	</dd>
	<dt><a name="com.mchange.v2.log.NameTransformer" />com.mchange.v2.log.NameTransformer</dt>
	<dd>
	  <div class="propdesc">
	    By default, c3p0 uses very fine-grained logging, in general with one logger for each
	    c3p0 class. For a variety of reasons, some users may prefer fewer, more global loggers.
	    You may opt for one-logger-per-package by setting <tt>com.mchange.v2.log.NameTransformer</tt>
	    to the value <tt>com.mchange.v2.log.PackageNames</tt>. Advanced users can also define 
	    other strategies for organizing the number and names of loggers by setting this variable
	    to the fully-qualified class name of a custom implementation of the 
	    <tt>com.mchange.v2.log.NameTransformer</tt> interface.
	  </div>
	</dd>
	<dt><a name="com.mchange.v2.log.FallbackMLog.DEFAULT_CUTOFF_LEVEL" />com.mchange.v2.log.FallbackMLog.DEFAULT_CUTOFF_LEVEL</dt>
	<dd>
	  <div class="propdesc">
	    If, whether by choice or by necessity, you are using c3p0's <tt>System.err</tt> fallback logger, you can
	    use this parameter to control how detailed c3p0's logging should be. Any of the following values (taken
	    from the jdk1.4 logging library) are acceptable:
	    <ul>
	      <li><tt>OFF</tt></li>
	      <li><tt>SEVERE</tt></li>
	      <li><tt>WARNING</tt></li>
	      <li><tt>INFO</tt></li>
	      <li><tt>CONFIG</tt></li>
	      <li><tt>FINE</tt></li>
	      <li><tt>FINER</tt></li>
	      <li><tt>FINEST</tt></li>
	      <li><tt>ALL</tt></li>
	    </ul>
	    This property defaults to <tt>INFO</tt>.
	  </div>
	</dd>
      </dl>
    </div>
    <h2><a name="performance">Performance</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	Enhanced performance is the purpose of Connection and Statement pooling, and a
	major goal of the c3p0 library. For most applications, Connection pooling
	will provide a significant performance gain, especially if you are acquiring
	an unpooled Connection for each client access. If you are letting a single,
	shared Connection serve many clients to avoid Connection acquisition overhead, 
	you may suffer performance issues and problems managing transactions when 
	your Connection is under concurrent load; Connection pooling will enable you 
	to switch to a one Connection-per-client model with little or no cost. 
	If you are writing Enterprise Java Beans, you may be tempted to acquire a 
	Connection once and not return it until the bean is about to be destroyed or
	passivated. But this can be resource-costly, as dormant pooled 
	beans needlessly hold the Connection's network and database resources. 
	Connection pooling permits beans to only "own" 
	a Connection while they are using it.  
      </p>
      <p>
	But, there are performance costs to c3p0 as well. In order to implement 
	automatic cleanup of unclosed <tt>ResultSets</tt> and <tt>Statements</tt> when parent resources 
	are returned to pools, all client-visible <tt>Connections</tt>, <tt>ResultSets</tt>, <tt>Statements</tt> 
	are really wrappers around objects provided by an underlying unpooled DataSource 
	or "traditional" JDBC driver. Thus, there is some extra overhead to all JDBC calls.
      </p>
      <p>
	Some attention has been paid to minimizing the "wrapper" overhead of c3p0. In
	my environment, the wrapper overhead amounts from several hundreths to several
	thousandths of the cost of Connection acquisition, so unless you are making
	many, many JDBC calls in fast succession, there will be a net 
	gain in performance and resource-utilization efficiency. 
	Significantly, the overhead associated with ResultSet operations (where
	one might iterate through a table with thousands of records) appears to be 
	negligibly small.
      </p>
    </div>
    <h2><a name="known_shortcomings">Known Shortcomings</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <ul>
	<li>
	  <p>
	    Connections and Statements are pooled on a per-authentication basis.
	    So, if one pool-backed DataSource is used to acquire Connections both
	    for [<tt>user</tt>=alice, <tt>password</tt>=secret1] and [<tt>user</tt>=bob, <tt>password</tt>=secret2],
	    there will be two distinct pools, and the DataSource might in the
	    worst case manage twice the number of Connections specified by the
	    <tt>maxPoolSize</tt> property.
	  </p>
	</li>
	<li>
	  <p>
	    The overhead of Statement pooling is too high. For drivers that
	    do not perform significant preprocessing of PreparedStatements, the
	    pooling overhead outweighs any savings. Statement pooling is thus
	    turned off by default. If your driver does preprocess <tt>PreparedStatements</tt>,
	    especially if it does so via IPC with the RDBMS, you will probably
	    see a significant performance gain by turning Statement pooling on. (Do this by
	    setting the configuration property <tt>maxStatements</tt> or <tt>maxStatementsPerConnection</tt>
	    to a value greater than zero.).
	  </p>
	</li>
      </ul>
    </div>
    <h2><a name="feedback_and_support">Feedback and Support</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	Please provide any and all feedback to &lt;<a href="mailto:swaldman@mchange.com">swaldman@mchange.com</a>&gt! 
	Also, feel free to join and ask questions on the <tt>c3p0-users</tt> mailing list.
	Sign up at <a href="http://sourceforge.net/projects/c3p0/">http://sourceforge.net/projects/c3p0/</a>
      </p>
      <p>  
	Thank you for using c3p0!!!
      </p>
    </div>
    <h2><a name="configuration_properties">Appendix A: Configuration Properties</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <dl class="properties">
	<dt><a name="acquireIncrement" />acquireIncrement</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    Determines how many connections at a time c3p0 will try to acquire when the pool is exhausted. 
	    [See <a href="#basic_pool_configuration">"Basic Pool Configuration"</a>]
	  </div>
	</dd>
	<dt><a name="acquireRetryAttempts" />acquireRetryAttempts</dt>
	<dd>
	  <div class="default">Default: 30</div>
	  <div class="propdesc">
	    Defines how many times c3p0 will try to acquire a new Connection from the database before giving up. If
	    this value is less than or equal to zero, c3p0 will keep trying to fetch a Connection indefinitely.	  
	    [See <a href="#configuring_recovery">"Configuring Recovery From Database Outages"</a>]
	  </div>
	</dd>
	<dt><a name="acquireRetryDelay" />acquireRetryDelay</dt>
	<dd>
	  <div class="default">Default: 1000</div>
	  <div class="propdesc">
	    Milliseconds, time c3p0 will wait between acquire attempts.
	    [See <a href="#configuring_recovery">"Configuring Recovery From Database Outages"</a>]
	  </div>
	</dd>
	<dt><a name="autoCommitOnClose" />autoCommitOnClose</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    The JDBC spec is unforgivably silent on what should happen to unresolved, pending
            transactions on Connection close. C3P0's default policy is to rollback any uncommitted, pending
            work. (I think this is absolutely, undeniably the right policy, but there is no consensus among JDBC driver vendors.) 
            Setting <tt>autoCommitOnClose</tt> to true causes uncommitted pending work to be committed, rather than rolled
            back on Connection close. [<i>Note: Since the spec is absurdly unclear on this question, application authors who wish
              to avoid bugs and inconsistent behavior should ensure that all transactions are explicitly either committed or
              rolled-back before close is called.</i>]
	    [See <a href="#configuring_unresolved">"Configuring Unresolved Transaction Handling"</a>]
	  </div>
	</dd>
	<dt><a name="automaticTestTable" />automaticTestTable</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    If provided, c3p0 will create an empty table of the specified name, and use queries against that table to
	    test the Connection. If <tt>automaticTestTable</tt> is provided, c3p0 will generate its own test query, therefore
	    any <tt>preferredTestQuery</tt> set will be ignored. You should not work with the named table after c3p0 creates
	    it; it should be strictly for c3p0's use in testing your Connection. (If you define your own ConnectionTester, it
	    must implement the <a href="apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html">QueryConnectionTester</a>
	    interface for this parameter to be useful.) [See <a href="#configuring_connection_testing">"Configuring Connection Testing"</a>]
	  </div>
	</dd>
	<dt><a name="breakAfterAcquireFailure" />breakAfterAcquireFailure</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    If true, a pooled DataSource will declare itself broken and be permanently closed if
	    a Connection cannot be obtained from the database after making <tt>acquireRetryAttempts</tt> to acquire one.
	    If false, failure to obtain a Connection will cause all Threads waiting for the pool to acquire a Connection
	    to throw an Exception, but the DataSource will remain valid, and will attempt to acquire again following
	    a call to <tt>getConnection()</tt>.
	    [See <a href="#configuring_recovery">"Configuring Recovery From Database Outages"</a>]
	  </div>
	</dd>
	<dt><a name="checkoutTimeout" />checkoutTimeout</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The number of milliseconds a client calling getConnection() will wait for a Connection to be checked-in or acquired
	    when the pool is exhausted. Zero means wait indefinitely. Setting any positive value will cause the getConnection()
	    call to time-out and break with an <tt>SQLException</tt> after the specified number of milliseconds.
	  </div>
	</dd>
	<dt><a name="connectionTesterClassName" />connectionTesterClassName</dt>
	<dd>
	  <div class="default">Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester</div>
	  <div class="propdesc">
	    The fully qualified class-name of an implememtation of the <a href="apidocs/com/mchange/v2/c3p0/ConnectionTester.html"><tt>ConnectionTester</tt></a>
	    interface, or <a href="apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html"><tt>QueryConnectionTester</tt></a> if you would like instances
	    to have access to a user-configured <tt>preferredTestQuery</tt>. This can be used to customize how c3p0 DataSources test Connections, but with
	    the introduction of <tt>automaticTestTable</tt> and <tt>preferredTestQuery</tt> configuration parameters, "rolling your own" should be overkill
	    for most users.
	    [See <a href="#configuring_connection_testing">"Configuring Connection Testing"</a>
	  </div>
	</dd>
	<dt><a name="factoryClassLocation" />factoryClassLocation</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    DataSources that will be bound by JNDI and use that API's Referenceable interface
            to store themselves may specify a URL from which the class capable of dereferencing 
            a them may be loaded. If (as is usually the case) the c3p0 libraries will be locally
            available to the JNDI service, leave this set as null.	
	  </div>
	</dd>
	<dt><a name="forceIgnoreUnresolvedTransactions" />forceIgnoreUnresolvedTransactions</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    <b><i>Strongly disrecommended. Setting this to <tt>true</tt> may lead to subtle and bizarre bugs.</i></b>
            This is a terrible setting, leave it alone unless absolutely necessary. It is here to workaround
            broken databases / JDBC drivers that do not properly support transactions, but that allow Connections'
            <tt>autoCommit</tt> flags to go to false regardless. If you are using a database that supports transactions
            "partially" (this is oxymoronic, as the whole point of transactions is to perform operations reliably and
            completely, but nonetheless such databases are out there), if you feel comfortable ignoring the fact that Connections
            with <tt>autoCommit == false</tt> may be in the middle of transactions and may hold locks and other resources,
            you may turn off c3p0's wise default behavior, which is to protect itself, as well as the usability and consistency
            of the database, by either rolling back (default) or committing (see <tt>c3p0.autoCommitOnClose</tt> <i>above</i>)
            unresolved transactions. <b>This should only be set to true when you are sure you are using a database that
              allows Connections' autoCommit flag to go to false, but offers no other meaningful support of transactions. Otherwise
              setting this to true is just a bad idea.</b>	
	    [See <a href="#configuring_unresolved">"Configuring Unresolved Transaction Handling"</a>]
	  </div>
	</dd>
	<dt><a name="idleConnectionTestPeriod"/>idleConnectionTestPeriod</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    If this is a number greater than 0, c3p0 will test all idle, pooled but unchecked-out connections, 
	    every this number of seconds. [See <a href="#configuring_connection_testing">"Configuring Connection Testing"</a>]
	  </div>
	</dd>
	<dt><a name="initialPoolSize"/>initialPoolSize</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    Number of Connections a pool will try to acquire upon startup. Should be between <tt>minPoolSize</tt> and
	    <tt>maxPoolSize</tt>.
	    [See <a href="#basic_pool_configuration">"Basic Pool Configuration"</a>]
	  </div>
	</dd>
	<dt><a name="maxIdleTime" />maxIdleTime</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    Seconds a Connection can remain pooled but unused before being discarded. Zero means idle connections never expire.
	    [See <a href="#basic_pool_configuration">"Basic Pool Configuration"</a>]
	  </div>
	</dd>
	<dt><a name="maxPoolSize"/>maxPoolSize</dt>
	<dd>
	  <div class="default">Default: 15</div>
	  <div class="propdesc">
	    Maximum number of Connections a pool will maintain at any given time.
	    [See <a href="#basic_pool_configuration">"Basic Pool Configuration"</a>]
	  </div>
	</dd>
	<dt><a name="maxStatements" />maxStatements</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The size of c3p0's global PreparedStatement cache. If both <tt>maxStatements</tt> and <tt>maxStatementsPerConnection</tt>
	    are zero, statement caching will not be enabled. If <tt>maxStatements</tt> is zero but <tt>maxStatementsPerConnection</tt>
	    is a non-zero value, statement caching will be enabled, but no global limit will be enforced, only the per-connection maximum.
	    <tt>maxStatements</tt> controls the total number of Statements cached,
	    for all Connections. If set, it should be a fairly large number, as each pooled Connection requires its own,
	    distinct flock of cached statements. As a guide, consider how many distinct PreparedStatements are used
	    <i>frequently</i> in your application, and multiply that number by <tt>maxPoolSize</tt> to arrive at an appropriate
	    value. Though <tt>maxStatements</tt> is the JDBC standard parameter for controlling statement caching, users may
	    find c3p0's alternative <tt>maxStatementsPerConnection</tt> more intuitive to use.
	    [See <a href="#configuring_statement_pooling">"Configuring Statement Pooling"</a>]
	  </div>
	</dd>
	<dt><a name="maxStatementsPerConnection" />maxStatementsPerConnection</dt>
	<dd>
	  <div class="default">Default: 0</div>
	  <div class="propdesc">
	    The number of PreparedStatements c3p0 will cache for a single pooled Connection. 
	    If both <tt>maxStatements</tt> and <tt>maxStatementsPerConnection</tt>
	    are zero, statement caching will not be enabled. If <tt>maxStatementsPerConnection</tt> is zero but <tt>maxStatements</tt>
	    is a non-zero value, statement caching will be enabled, and a global limit enforced, but otherwise no limit will be set 
	    on the number of cached statements for a single Connection.
	    If set, maxStatementsPerConnection should be set to about the number distinct PreparedStatements that are used
	    <i>frequently</i> in your application, plus two or three extra so infrequently statements don't force the more common
	    cached statements to be culled. Though <tt>maxStatements</tt> is the JDBC standard parameter for controlling statement caching,
	    users may find <tt>maxStatementsPerConnection</tt> more intuitive to use.
	    [See <a href="#configuring_statement_pooling">"Configuring Statement Pooling"</a>]
	  </div>
	</dd>
	<dt><a name="minPoolSize"/>minPoolSize</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    Minimum number of Connections a pool will maintain at any given time.
	    [See <a href="#basic_pool_configuration">"Basic Pool Configuration"</a>]
	  </div>
	</dd>
	<dt><a name="numHelperThreads" />numHelperThreads</dt>
	<dd>
	  <div class="default">Default: 3</div>
	  <div class="propdesc">
	    c3p0 is very asynchronous. Slow JDBC operations are generally 
            performed by helper threads that don't hold contended locks. Spreading
            these operations over multiple threads can significantly improve performance
            by allowing multiple operations to be performed simultaneously.	
	  </div>
	</dd>
	<dt><a name="overrideDefaultUser" />overrideDefaultUser</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    Forces the username that should by PooledDataSources when a user calls the default
	    getConnection() method. This is primarily useful when applications are pooling Connections
	    from a non-c3p0 unpooled DataSource. Applications that use <tt>ComboPooledDataSource</tt>, 
	    or that wrap any c3p0-implemented unpooled DataSource can use the simple 
	    <a href="#user">user</a> property.
<!--
	    C3P0 PooledDataSources, implicitly or explicity, are wrappers around unpooled DataSources.
	    For most users, the unpooled DataSource is c3p0's own DriverManagerDataSource, but users are
	    welcome to wrap other DataSource implementations. Per the JDBC 2.0 spec, DataSources may offer
	    standard properties "user" and "password". If present, c3p0 PooledDataSources use these properties 
	    to determine what kind of authentication to use. If absent, PooledDataSources use the unpooled 
	    DataSource's default getConnection() method. Some DataSources offer one but not both of the
	    standard properties, which confuses c3p0.
--> 
	  </div>
	</dd>
	<dt><a name="overrideDefaultPassword" />overrideDefaultPassword</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    Forces the password that should by PooledDataSources when a user calls the default
	    getConnection() method. This is primarily useful when applications are pooling Connections
	    from a non-c3p0 unpooled DataSource. Applications that use <tt>ComboPooledDataSource</tt>, 
	    or that wrap any c3p0-implemented unpooled DataSource can use the simple
	    <a href="#password">password</a> property.
	  </div>
	</dd>
	<dt><a name="password" />password</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    For applications using <tt>ComboPooledDataSource</tt> or any 
	    c3p0-implemented unpooled DataSources &mdash; <tt>DriverManagerDataSource</tt> or the
	    DataSource returned by <tt>DataSources.unpooledDataSource( ... )</tt> &mdash;
	    defines the password that will be used for the DataSource's default 
	    <tt>getConnection()</tt> method. (See also <a href="#user">user</a>.)
	  </div>
	</dd>
	<dt><a name="preferredTestQuery" />preferredTestQuery</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    Defines the query that will be executed for all connection tests, if the default ConnectionTester (or some
	    other implementation of <a href="apidocs/com/mchange/v2/c3p0/QueryConnectionTester.html">QueryConnectionTester</a>) 
	    is being used. Defining a <tt>preferredTestQuery</tt>
	    that will execute quickly in your database may dramatically speed up Connection tests. (If no <tt>preferredTestQuery</tt>
	    is set, the default ConnectionTester executes a <tt>getTables()</tt> call on the Connection's DatabaseMetaData.
	    Depending on your database, this may execute more slowly than a "normal" database query.) <b>NOTE: The table against
            which your <tt>preferredTestQuery</tt> will be run must exist in the database schema <i>prior</i> to your initialization
            of your DataSource. If your application defines its own schema, try <tt>automaticTestTable</tt> instead.</b>
            [See <a href="#configuring_connection_testing">"Configuring Connection Testing"</a>]
	  </div>
	</dd>
	<dt><a name="propertyCycle" />propertyCycle</dt>
	<dd>
	  <div class="default">Default: 300</div>
	  <div class="propdesc">
	    Maximum time in seconds before user configuration constraints are enforced.
            c3p0 enforces configuration constraints continually, and ignores this parameter.
            It is included for JDBC 3 completeness.
	  </div>
	</dd>
	<dt><a name="testConnectionOnCheckin" />testConnectionOnCheckin</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
            If true, an operation will be performed asynchronously at every connection checkin to verify that the connection is valid.
	    Use in combination with <tt>idleConnectionTestPeriod</tt> for quite reliable, always asynchronous Connection testing.
	    Also, setting an <tt>automaticTestTable</tt> or <tt>preferredTestQuery</tt> will usually speed up all connection tests.
            [See <a href="#configuring_connection_testing">"Configuring Connection Testing"</a>]
	  </div>
	</dd>
	<dt><a name="testConnectionOnCheckout" />testConnectionOnCheckout</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    <b><i>Use only if necessary. Expensive.</i></b>
            If true, an operation will be performed at every connection checkout to verify that the connection is valid.
            <b>Better choice:</b> verify connections periodically using <tt>idleConnectionTestPeriod</tt>. Also, setting an
	    <tt>automaticTestTable</tt> or <tt>preferredTestQuery</tt> will usually speed up all connection tests.
            [See <a href="#configuring_connection_testing">"Configuring Connection Testing"</a>]
	  </div>
	</dd>
	<dt><a name="user" />user</dt>
	<dd>
	  <div class="default">Default: null</div>
	  <div class="propdesc">
	    For applications using <tt>ComboPooledDataSource</tt> or any 
	    c3p0-implemented unpooled DataSources &mdash; <tt>DriverManagerDataSource</tt> or the
	    DataSource returned by <tt>DataSources.unpooledDataSource()</tt> &mdash;
	    defines the username that will be used for the DataSource's default 
	    <tt>getConnection()</tt> method. (See also <a href="#password">password</a>.)
	  </div>
	<dt><a name="usesTraditionalReflectiveProxies" />usesTraditionalReflectiveProxies</dt>
	<dd>
	  <div class="default">Default: false</div>
	  <div class="propdesc">
	    c3p0 originally used reflective dynamic proxies for implementations of Connections and other JDBC
	    interfaces. As of c3p0-0.8.5, non-reflective, code-generated implementations are used instead. As
	    this was a major change, and the old codebase had been extensively used and tested, this parameter
	    was added to allow users to revert of they had problems. The new, non-reflexive implementation is
	    faster, and has now been widely deployed and tested, so it is unlikely that this parameter will be useful.
	    Both the old reflective and newer non-reflective codebases are being maintained, but support for the
	    older codebase may (or may not) be dropped in the future.
 	  </div>
	</dd>
      </dl>
    </div>
    <hr/>
      <h2>
	<a name="configuration_files">Configuration Files, etc.</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h2>
      <div class="sectiontext">
	<p>
	  c3p0 configuration parameters can be set 
	  <a href="#programmatic_configuration">directly in Java code</a>, 
	  via a <a href="#c3p0_properties">simple Java properties file</a>,
	  via an <a href="#c3p0-config.xml">XML configuration file</a>, or  
	  via <a href="#system_properties">System properties</a>.
	  Any which way
	  works (the the XML configuration is most powerful, though, as it supports multiple named configurations and
	  per-user overrides. Choose whatever works best for you.
	</p>
	<h3>
	  <a name="c3p0_properties">Overriding c3p0 defaults via <tt>c3p0.properties</tt></a>
	  <span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
	</h3>
	<p>
	  To override the library's built-in defaults, create a file called <tt>c3p0.properties</tt>
	  and place it at the "root" of your classpath or classloader. For a typical standalone
	  application, that means place the file in a directory named in your <tt>CLASSPATH</tt>
	  environment variable. For a typical web-application, the file should be placed in 
	  <tt>WEB-INF/classes</tt>. In general, the file must be available as a classloader
	  resource under the name <tt>/c3p0.properties</tt>, in the classloader that loaded
	  c3p0's jar file. Review the API docs (especilly <tt>getResource...</tt> methods) of 
	  <tt>java.lang.Class</tt>, <tt>java.lang.ClassLoader</tt>, and <tt>java.util.ResourceBundle</tt> 
	  if this is unfamiliar.
	</p>
	<p>
	  The format of <tt>c3p0.properties</tt> should be a normal Java Properties file format,
	  whose keys are c3p0 configurable properties. See <a href="#configuration_properties">Appendix A</a>.
	  for the specifics. An example <tt>c3p0.properties</tt> file is produced below:
	</p>
	<div class="example">
# turn on statement pooling
c3p0.maxStatements=150
	
# close pooled Connections that go unused for
# more than half an hour
c3p0.maxIdleTime=1800
	</div>
	<h3>
	  <a name="system_properties">Overriding c3p0 defaults with a System properties</a>
	  <span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
	</h3>
	<p>
	  c3p0 properties can also be defined as System properties, using the same "c3p0." prefix for properties
	  specified in a <tt>c3p0.properties</tt> file.
	</p>
	<div class="example">
swaldman% java -Dc3p0.maxStatements=150 -Dc3p0.maxIdleTime=1800 example.MyC3P0App
	</div>
	<p>
	  System properties override settings in c3p0.properties. Please see 
	  <a href="#configuration_precedence">Precedence of Configuration Settings</a> for more information.
	</p>
	<h3>
	  <a name="c3p0-config.xml">Named and Per-User configuration: Overriding c3p0 defaults via <tt>c3p0-config.xml</tt></a>
	  <span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
	</h3>
	<p>
	  As of c3p0-0.9.1, you can define multiple configurations in an XML configuration file, and specify in your code which
	  configuration to use. For any configurations (including the unnamed default configuration), you can define overrides
	  for a particular database user. For example, if several applications access your database under different authentication
	  credentials, you might define <tt>maxPoolSize</tt> to be 100 for user <tt>highVolumeApp</tt>, but only 10 for user 
	  <tt>lowLoadApp</tt>. (Recall that Connections associated with different authentication credentials
	  are of necessity separated into separate pools, so it makes sense that these could be configured separately.)
	</p>
	<p>
	  You can use the XML config file for all c3p0 configuration, including configuration of defaults. However, for users who
	  don't want or need the extra complexity, the c3p0.properties file will continue to be supported.
	</p>
	<p>
	  By default, c3p0 will look for an XML configuration file in its classloader's resource path under the name "/c3p0-config.xml".
	  That means the XML file should be placed in a directly or jar file directly named in your applications CLASSPATH, in WEB-INF/classes,
	  or some similar location. If you prefer not to bundle your configuration with your code, you can specify an ordinary filesystem location for c3p0's
	  configuration file via the system property <tt>com.mchange.v2.c3p0.cfg.xml</tt>.
	</p>
	<p>
	  Here is an example <tt>c3p0-config.xml</tt> file:
	</p>
	<div class="example">
&lt;c3p0-config&gt;
  &lt;default-config&gt;
    &lt;property name="automaticTestTable"&gt;con_test&lt;/property&gt;
    &lt;property name="checkoutTimeout"&gt;30000&lt;/property&gt;
    &lt;property name="idleConnectionTestPeriod"&gt;30&lt;/property&gt;
    &lt;property name="initialPoolSize"&gt;10&lt;/property&gt;
    &lt;property name="maxIdleTime"&gt;30&lt;/property&gt;
    &lt;property name="maxPoolSize"&gt;100&lt;/property&gt;
    &lt;property name="minPoolSize"&gt;10&lt;/property&gt;
    &lt;property name="maxStatements"&gt;200&lt;/property&gt;

    &lt;user-overrides user="test-user"&gt;
      &lt;property name="maxPoolSize"&gt;10&lt;/property&gt;
      &lt;property name="minPoolSize"&gt;1&lt;/property&gt;
      &lt;property name="maxStatements"&gt;0&lt;/property&gt;
    &lt;/user-overrides&gt;

  &lt;/default-config&gt;

  &lt;!-- This app is massive! --&gt;
  &lt;named-config name="intergalactoApp"&gt; 
    &lt;property name="acquireIncrement"&gt;50&lt;/property&gt;
    &lt;property name="initialPoolSize"&gt;100&lt;/property&gt;
    &lt;property name="minPoolSize"&gt;50&lt;/property&gt;
    &lt;property name="maxPoolSize"&gt;1000&lt;/property&gt;

    &lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt;
    &lt;property name="maxStatements"&gt;0&lt;/property&gt; 
    &lt;property name="maxStatementsPerConnection"&gt;5&lt;/property&gt;

    &lt;!-- he's important, but there's only one of him --&gt;
    &lt;user-overrides user="master-of-the-universe"&gt; 
      &lt;property name="acquireIncrement"&gt;1&lt;/property&gt;
      &lt;property name="initialPoolSize"&gt;1&lt;/property&gt;
      &lt;property name="minPoolSize"&gt;1&lt;/property&gt;
      &lt;property name="maxPoolSize"&gt;5&lt;/property&gt;
      &lt;property name="maxStatementsPerConnection"&gt;50&lt;/property&gt;
    &lt;/user-overrides&gt;
  &lt;/named-config&gt;
&lt;/c3p0-config&gt;
	</div>
	<p>
	  To use a named configuration, you specify the config name when creating your DataSource. For example, using
	  <a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html"><tt>ComboPooledDataSource</tt></a>:
	</p>
	<div class="example">
ComboPooledDataSource cpds = new ComboPooledDataSource("intergalactoApp");  
	</div>
	<p>
	  Or using the
	  <a href="apidocs/com/mchange/v2/c3p0/DataSources.html"><tt>DataSources</tt></a> factory class:
	</p>
	<div class="example">
DataSource ds_pooled = DataSources.pooledDataSource( ds_unpooled, "intergalactoApp" );
	</div>
	<h3>
	  <a name="programmatic_configuration">Programmatic configuration of DataSource instances</a>
	  <span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
	</h3>
	<h3>
	  <a name="configuration_precedence">Precedence of Configuration Settings</a>
	  <span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
	</h3>
	<p>
	  c3p0 now permits configuration parameters to be set in a number of different ways and places. Fortunately,
	  there is a clear order of precedence that determines which configuration will "take" in the event of conflicting
	  settings. Conceptually, c3p0 goes down this list from top to bottom, using the first setting it finds. 
	</p>
	<p>
	  Most applications will never use per-user or named configurations. For these applications, we
	  present a simplified precedence hierarchy:
	</p>
	<div align="center">
	  <ol class="precedence">
	    <li>Configuration values programmatically set.</li>
	    <li>System property setting of configuration value.</li>
	    <li>Configuration values taken from the default configuration a <tt>c3p0-config.xml</tt> file.</li>
	    <li>Configuration values specified in a <tt>c3p0.properties</tt> file</li>
	    <li>c3p0's hard-coded default values.</li>
	  </ol>
	</div>
	<p>
	  For applications that do use advanced named and per-user configurations, here is the complete, normative precedence hierarchy:
	</p>
	<div align="center">
	  <ol class="precedence">
	    <li>
	      User-specific overrides programmatically set via:
	      <ul>
		<li><a href="apidocs/com/mchange/v2/c3p0/ComboPooledDataSource.html#setUserOverridesAsString"><tt>ComboPooledDataSource.setUserOverridesAsString()</tt></a></li>
		<li><a href="apidocs/com/mchange/v2/c3p0/WrapperConnectionPoolDataSource.html#setUserOverridesAsString"><tt>WrapperConnectionPoolDataSource.setUserOverridesAsString()</tt></a></li>
	      </ul>
	      Note that programmatically setting user-specific overrides <u>replaces</u> all user-specific configuration taken from
	      other sources. If you want to merge programmatic changes with preconfigured overrides, you'll have to use <tt>getUserOverridesAsString()</tt>
	      and modify the original settings before replacing.
	    </li>
	    <li>User-specific overrides taken from a DataSource's named configuration (specified in <tt>c3p0-config.xml</tt>)</li>
	    <li>User-specific overrides taken from the default configuration (specified in <tt>c3p0-config.xml</tt>)</li>
	    <li>Non-user-specific values programmatically set.</li>
	    <li>Non-user-specific values taken from a DataSource's named configuration (specified in <tt>c3p0-config.xml</tt>)</li>
	    <li>System property setting of configuration value.</li>
	    <li>Non-user-specific values taken from the default configuration (specified in <tt>c3p0-config.xml</tt>)</li>
	    <li>Values specified in a <tt>c3p0.properties</tt> file</li>
	    <li>c3p0's hard-coded default values.</li>
	  </ol>
	</div>
      </div>
      <h2>
	<a name="hibernate-specific">Appendix C: Hibernate-specific notes</a>
	<span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span>
      </h2>
      <div class="sectiontext">
      <p>
	Hibernate's C3P0ConnectionProvider explicitly sets 7 c3p0 configuration properties, based on your hibernate
	configuration, <b>overriding</b> any configuration you may have set in a <tt>c3p0.properties</tt> file. If you
	are using Hibernate's C3P0ConnectionProvider you <b>must</b> set the following
	properties in your hibernate configuration, using hibernate-specific configuration keys. All other properties
	must be defined as usual in a <tt>c3p0.properties</tt> file. This is confusing, and will hopefully be simplified
	some time in the future, but for now...
      </p>
      <p>
	The following properties must be set in your hibernate configuration:
      </p>
      <div class="hibernate_props">
	<table class="hibernate_props">
	  <tr>
	    <th>c3p0-native property name</th><th>hibernate configuration key</th>
	  </tr>
	  <tr>
	    <td>c3p0.acquireIncrement</td><td>hibernate.c3p0.acquire_increment</td>
	  </tr>
	  <tr>
	    <td>c3p0.idleConnectionTestPeriod</td><td>hibernate.c3p0.idle_test_period</td>
	  </tr>
	  <tr>
	    <td>c3p0.initialPoolSize</td><td><span class="hibparam_comment">not available -- uses minimum size</span></td>
	  </tr>
	  <tr>
	    <td>c3p0.maxIdleTime</td><td>hibernate.c3p0.timeout</td>
	  </tr>
	  <tr>
	    <td>c3p0.maxPoolSize</td><td>hibernate.c3p0.max_size</td>
	  </tr>
	  <tr>
	    <td>c3p0.maxStatements</td><td>hibernate.c3p0.max_statements</td>
	  </tr>
	  <tr>
	    <td>c3p0.minPoolSize</td><td>hibernate.c3p0.min_size</td>
	  </tr>
	  <tr>
	    <td>c3p0.testConnectionsOnCheckout&nbsp;</td><td>hibernate.c3p0.validate <span class="hibparam_comment">hibernate 2.x only!</span></td>
	  </tr>
	</table>
      </div>
      <p>
	Remember -- these, and <i>only these</i>, properties must be defined in your hibernate configuration, or else
	they will be set to hibernate-specified defaults. All other configuration properties that you wish to set
	should be defined in a <tt>c3p0.properties</tt>	file. (See <a href="#c3p0_properties">"Overriding c3p0 defaults via c3p0.properties"</a>.)
      </p>
    </div>
    <hr/>
    <h2><a name="tomcat-specific">Appendix D: Configuring c3p0 DataSources in Tomcat</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	You can easily configure Apache's Tomcat web application server to use c3p0 pooled DataSources. 
	Below is a Tomcat 5.0  sample config to get you started. It's a fragment of Tomcat's <tt>conf/server.xml</tt> file,
	which should be modified to suit and placed inside a <tt>&lt;Context&gt;</tt> element.
      </p>
      <div class="example">
&lt;Resource name="jdbc/pooledDS" auth="Container" type="com.mchange.v2.c3p0.ComboPooledDataSource" /&gt;
&lt;ResourceParams name="jdbc/pooledDS"&gt;
  &lt;parameter&gt;
    &lt;name&gt;factory&lt;/name&gt;
    &lt;value&gt;org.apache.naming.factory.BeanFactory&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;driverClass&lt;/name&gt;
    &lt;value&gt;org.postgresql.Driver&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;jdbcUrl&lt;/name&gt;
    &lt;value&gt;jdbc:postgresql://localhost/c3p0-test&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;user&lt;/name&gt;
    &lt;value&gt;swaldman&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;password&lt;/name&gt;
    &lt;value&gt;test&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;minPoolSize&lt;/name&gt;
    &lt;value&gt;5&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;maxPoolSize&lt;/name&gt;
    &lt;value&gt;15&lt;/value&gt;
  &lt;/parameter&gt;
  &lt;parameter&gt;
    &lt;name&gt;acquireIncrement&lt;/name&gt;
    &lt;value&gt;5&lt;/value&gt;
  &lt;/parameter&gt;
&lt;/ResourceParams&gt;
      </div>
      <p>For Tomcat 5.5, try something like the following (thanks to Carl F. Hall for the sample!):</p>
      <div class="example">
	&lt;Resource auth="Container"
	          description="DB Connection"
		  driverClass="com.mysql.jdbc.Driver"
		  maxPoolSize="4"
		  minPoolSize="2"
		  acquireIncrement="1"
		  name="jdbc/TestDB"
		  user="test"
		  password="ready2go"
		  factory="org.apache.naming.factory.BeanFactory"
		  type="com.mchange.v2.c3p0.ComboPooledDataSource"
		  jdbcUrl="jdbc:mysql://localhost:3306/test?autoReconnect=true" /&gt;
      </div>
      <p>
	The rest is standard J2EE stuff: You'll need to declare your DataSource reference in your <tt>web.xml</tt>
	file:
      </p>
	
      <div class="example">
&lt;resource-ref&gt;
  &lt;res-ref-name&gt;jdbc/pooledDS&lt;/res-ref-name&gt;
  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
  &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
      </div>
      <p>      
	And you can access your DataSource from code within your web application like this:
      </p>
      <div class="example">
InitialContext ic = new InitialContext();
DataSource ds = (DataSource) ic.lookup("java:comp/env/jdbc/pooledDS");
      </div>
      <p>
	That's it!
      </p>
    </div>
    <hr/>
    <h2><a name="jboss-specific">Appendix E: JBoss-specific notes</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	To use c3p0 with JBoss:
	<ol>
	  <li>
	    Place c3p0's jar file in the <tt>lib</tt> directory of your 
	    jboss server instance (e.g. <tt>${JBOSS_HOME}/server/default/lib</tt>)
	  </li>
	  <li>
	    Modify the file below, and save it as <tt>c3p0-service.xml</tt> in the 
	    <tt>deploy</tt> directory of your jboss server (e.g. <tt>${JBOSS_HOME}/server/default/deploy</tt>).
	    Note that parameters must be capitalized in this file, but otherwise they are defined as described
	    above.
	  </li>
	</ol>
      <div class="example">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE server&gt;

&lt;server&gt;

   &lt;mbean code="com.mchange.v2.c3p0.mbean.C3P0PooledDataSource"
          name="jboss:service=C3P0PooledDataSource"&gt;
     
      &lt;attribute name="JndiName"&gt;java:PooledDS&lt;/attribute&gt;
      &lt;attribute name="JdbcUrl"&gt;jdbc:postgresql://localhost/c3p0-test&lt;/attribute&gt;
      &lt;attribute name="DriverClass"&gt;org.postgresql.Driver&lt;/attribute&gt;
      &lt;attribute name="User"&gt;swaldman&lt;/attribute&gt;
      &lt;attribute name="Password"&gt;test&lt;/attribute&gt;

      &lt;!-- Uncomment and set any of the optional parameters below --&gt;
      &lt;!-- See c3p0's docs for more info.                         --&gt;

      &lt;!-- &lt;attribute name="AcquireIncrement"&gt;3&lt;/attribute&gt;                     --&gt;
      &lt;!-- &lt;attribute name="AcquireRetryAttempts"&gt;30&lt;/attribute&gt;                --&gt;
      &lt;!-- &lt;attribute name="AcquireRetryDelay"&gt;1000&lt;/attribute&gt;                 --&gt;
      &lt;!-- &lt;attribute name="AutoCommitOnClose"&gt;false&lt;/attribute&gt;                --&gt;
      &lt;!-- &lt;attribute name="AutomaticTestTable"&gt;&lt;/attribute&gt;                    --&gt;
      &lt;!-- &lt;attribute name="BreakAfterAcquireFailure"&gt;false&lt;/attribute&gt;         --&gt;
      &lt;!-- &lt;attribute name="CheckoutTimeout"&gt;0&lt;/attribute&gt;                      --&gt;
      &lt;!-- &lt;attribute name="ConnectionTesterClassName"&gt;0&lt;/attribute&gt;            --&gt;
      &lt;!-- &lt;attribute name="Description"&gt;A pooled c3p0 DataSource&lt;/attribute&gt;   --&gt;
      &lt;!-- &lt;attribute name="FactoryClassLocation"&gt;&lt;/attribute&gt;                  --&gt;
      &lt;!-- &lt;attribute name="ForceIgnoreUnresolvedTransactions"&gt;true&lt;/attribute&gt; --&gt;
      &lt;!-- &lt;attribute name="IdleConnectionTestPeriod"&gt;-1&lt;/attribute&gt;            --&gt;
      &lt;!-- &lt;attribute name="InitialPoolSize"&gt;3&lt;/attribute&gt;                      --&gt;
      &lt;!-- &lt;attribute name="MaxIdleTime"&gt;0&lt;/attribute&gt;                          --&gt;
      &lt;!-- &lt;attribute name="MaxPoolSize"&gt;15&lt;/attribute&gt;                         --&gt;
      &lt;!-- &lt;attribute name="MaxStatements"&gt;0&lt;/attribute&gt;                        --&gt;
      &lt;!-- &lt;attribute name="MaxStatementsPerConnection"&gt;0&lt;/attribute&gt;           --&gt;
      &lt;!-- &lt;attribute name="MinPoolSize"&gt;0&lt;/attribute&gt;                          --&gt;
      &lt;!-- &lt;attribute name="NumHelperThreads"&gt;3&lt;/attribute&gt;                     --&gt;
      &lt;!-- &lt;attribute name="PreferredTestQuery"&gt;&lt;/attribute&gt;                    --&gt;
      &lt;!-- &lt;attribute name="TestConnectionOnCheckin"&gt;false&lt;/attribute&gt;          --&gt;
      &lt;!-- &lt;attribute name="TestConnectionOnCheckout"&gt;false&lt;/attribute&gt;         --&gt;
      &lt;!-- &lt;attribute name="UsesTraditionalReflectiveProxies"&gt;false&lt;/attribute&gt; --&gt;


      &lt;depends&gt;jboss:service=Naming&lt;/depends&gt;
   &lt;/mbean&gt;

&lt;/server&gt;
      </div>
      </p>
    </div>
    <hr/>
    <h2><a name="oracle-specific">Appendix F: Oracle-specific API: createTemporaryBLOB() and createTemporaryCLOB()</a><span class="toplink"><a href="#contents"><img src="arrow_sm.png" width="20" alt="Go To Top"/></a></span></h2>
    <div class="sectiontext">
      <p>
	The Oracle thin JDBC driver provides a non-standard API for creating temporary BLOBs and CLOBs that
	requires users to call methods on the raw, Oracle-specific Connection implementation. Advanced users
	might use the <a href="#raw_connection_ops">raw connection operations</a> described above to access this
	functionality, but a convenience class is available in a separate jar file (<tt>c3p0-oracle-thin-extras-@c3p0.version@.jar</tt>)
	for easier access to this functionality. Please see the 
	<a href="apidocs-oracle-thin/index.html">API docs for <tt>com.mchange.v2.c3p0.dbms.OracleUtils</tt></a>
	for details.
      </p>
    </div>
    <hr/>
    <a href="#contents">Back to Contents</a>
  </body>
</html>
